/* ==========================================================
   ycalc.cup - Parser para el lenguaje Mini con FUNCIONES
   Construye el AST con soporte para funciones
   ========================================================== */

import java_cup.runtime.*;
import java.util.*;

parser code {:
    public void report_error(String message, Object info) {
        StringBuffer m = new StringBuffer("Error");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {
                m.append(" en línea " + (s.left + 1));
                if (s.right >= 0) m.append(", columna " + (s.right + 1));
            }
        }
        m.append(": " + message);
        System.err.println(m);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:}

/* ---------- Terminales ---------- */
terminal String ID;
terminal Integer NUMBER;

terminal VOID, INT;
terminal IF, THEN, ELSE, WHILE, RETURN;
terminal PLUS, MINUS, TIMES, DIVIDE;
terminal AND, OR, EQEQ, LT, GT, NOT;
terminal ASSIGN, SEMI, LPAREN, RPAREN, LBRACE, RBRACE, COMMA;

/* ---------- No terminales ---------- */
non terminal ProgramNode program;
non terminal FunctionListNode functions;
non terminal FunctionNode function;
non terminal String type;
non terminal ParamListNode params, nonempty_params;
non terminal ParamNode param;
non terminal BlockNode block;
non terminal DeclListNode decls;
non terminal DeclNode decl;
non terminal StmtListNode stmts;
non terminal StmtNode stmt;
non terminal ExprNode expr;
non terminal List<ExprNode> args, nonempty_args;

/* ---------- Precedencias ---------- */
precedence left OR;
precedence left AND;
precedence left EQEQ, LT, GT;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence right NOT;

/* ==========================================================
   Gramática con FUNCIONES
   ========================================================== */

program ::= functions:fs
          {:
              RESULT = new ProgramNode(fs);
              System.out.println("Programa Mini con funciones válido ✅");
          :}
          ;

/* ---------- Funciones ---------- */
functions ::= function:f
            {:
                FunctionListNode fl = new FunctionListNode();
                fl.add(f);
                RESULT = fl;
            :}
            | functions:fl function:f
            {:
                fl.add(f);
                RESULT = fl;
            :}
            ;

function ::= type:t ID:name LPAREN params:p RPAREN block:b
           {:
               RESULT = new FunctionNode(t, name, p, b);
           :}
           ;

type ::= INT
       {: RESULT = "int"; :}
       | VOID
       {: RESULT = "void"; :}
       ;

/* ---------- Parámetros ---------- */
params ::=
         {: RESULT = new ParamListNode(); :}
         | nonempty_params:p
         {: RESULT = p; :}
         ;

nonempty_params ::= param:p
                  {:
                      ParamListNode pl = new ParamListNode();
                      pl.add(p);
                      RESULT = pl;
                  :}
                  | nonempty_params:pl COMMA param:p
                  {:
                      pl.add(p);
                      RESULT = pl;
                  :}
                  ;

param ::= INT ID:name
        {: RESULT = new ParamNode("int", name); :}
        ;

/* ---------- Bloques ---------- */
block ::= LBRACE decls:ds stmts:st RBRACE
        {:
            RESULT = new BlockNode(ds, st);
        :}
        ;

/* ---------- Declaraciones ---------- */
decls ::=
          {: RESULT = new DeclListNode(); :}
        | decls:dl decl:d
          {:
              dl.add(d);
              RESULT = dl;
          :}
        ;

decl ::= INT ID:id SEMI
        {:
            RESULT = new DeclNode(id, "int");
        :}
        | INT ID:id ASSIGN expr:e SEMI
        {:
            RESULT = new DeclNode(id, "int", e);
        :}
        ;

/* ---------- Sentencias ---------- */
stmts ::=
          {: RESULT = new StmtListNode(); :}
        | stmts:sl stmt:s
          {:
              sl.add(s);
              RESULT = sl;
          :}
        ;

stmt ::= ID:id ASSIGN expr:e SEMI
        {:
            RESULT = new AssignNode(id, e);
        :}
        | RETURN expr:e SEMI
        {:
            RESULT = new ReturnNode(e);
        :}
        | RETURN SEMI
        {:
            RESULT = new ReturnNode(null);
        :}
        | IF LPAREN expr:cond RPAREN THEN block:thenblk
        {:
            RESULT = new IfNode(cond, thenblk, null);
        :}
        | IF LPAREN expr:cond RPAREN THEN block:thenblk ELSE block:elseblk
        {:
            RESULT = new IfNode(cond, thenblk, elseblk);
        :}
        | WHILE LPAREN expr:cond RPAREN block:body
        {:
            RESULT = new WhileNode(cond, body);
        :}
        ;

/* ---------- Expresiones ---------- */
expr ::=
          expr:l PLUS expr:r    {: RESULT = new BinOpNode("+", l, r); :}
        | expr:l MINUS expr:r   {: RESULT = new BinOpNode("-", l, r); :}
        | expr:l TIMES expr:r   {: RESULT = new BinOpNode("*", l, r); :}
        | expr:l DIVIDE expr:r  {: RESULT = new BinOpNode("/", l, r); :}
        | expr:l AND expr:r     {: RESULT = new BinOpNode("&&", l, r); :}
        | expr:l OR expr:r      {: RESULT = new BinOpNode("||", l, r); :}
        | expr:l EQEQ expr:r    {: RESULT = new BinOpNode("==", l, r); :}
        | expr:l LT expr:r      {: RESULT = new BinOpNode("<", l, r); :}
        | expr:l GT expr:r      {: RESULT = new BinOpNode(">", l, r); :}
        | NOT expr:e            {: RESULT = new UnaryOpNode("!", e); :}
        | MINUS expr:e          {: RESULT = new UnaryOpNode("-", e); :}
        | LPAREN expr:e RPAREN  {: RESULT = e; :}
        | ID:name LPAREN args:a RPAREN
        {: RESULT = new CallNode(name, a); :}
        | NUMBER:n              {: RESULT = new NumNode(n); :}
        | ID:id                 {: RESULT = new IdNode(id); :}
        ;

/* ---------- Argumentos de llamadas a función ---------- */
args ::=
       {: RESULT = new ArrayList<ExprNode>(); :}
       | nonempty_args:a
       {: RESULT = a; :}
       ;

nonempty_args ::= expr:e
                {:
                    List<ExprNode> list = new ArrayList<ExprNode>();
                    list.add(e);
                    RESULT = list;
                :}
                | nonempty_args:list COMMA expr:e
                {:
                    list.add(e);
                    RESULT = list;
                :}
                ;
